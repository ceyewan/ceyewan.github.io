- clone 系统调用不仅可以通过设置参数实现 fork 和 pthread_create，还可以通过参数实现新的命名空间的进程创建。并且会指定栈的大小，如果超出，就会栈溢出。
- IPC 进程间通信包括 POSIX 消息队列（mq_open、mq_send、mq_receive）、信号量（sem_open、sem_post、sem_wait）、共享内存（shm_open、mmap）；管道（pipe 匿名管道和 fifo 命名管道）；套接字（TCP/IP 网络套接字、Unix 域本地套接字 AF_UNIX，就是 docker 用的哪个 sock 文件）
- UnionFS 联合文件系统（OverlayFS），使用了 Whiteout 和**Opaque** 遮蔽技术
- containerd 并不直接创建容器进程，而是会使用 shim 作为垫片，大概链路是这样的，如果 containerd 重启也不会影响容器运行。而且 containerd 启动 shim 后，shim 会自己进行一次 " 第二次 fork"，使得最终的 shim 进程不再作为 containerd 的子进程，而是挂到 PID 1（systemd/init）下。这种 " 双向 fork" 机制实现了 containerd 与 shim 生命周期的解耦。systemd(1)─containerd(1234)─containerd-shim(5678)─nginx(9012)
- rund，阿里云提出来的，感觉大家都在讲这个
- Dockerfile 编写建议：
    - 使用 && 合并命令，减少文件系统的层数，清理包缓存；
    - 将不常变部分放在前面；
    - 多阶段构建，第一个阶段构建，第二阶段只拷贝可执行程序；
    - 使用轻量基础镜像，减小初始体积；
    - 使用 `.dockerignore` 文件。
- Host 模式，就是不使用网络隔离，直接用主机的，端口会冲突
- Container 模式，`--network container:<name>`，与其他容器共享网络命名空间；
- **Bridge 模式是 Docker 的默认网络模式** ，它为每个容器提供一个独立的网络命名空间（netns），并通过虚拟网卡连接到宿主机上的 `docker0` 网桥。这种设计让容器之间可以互相通信，并且通过 NAT 技术访问外部网络。容器内部可以通过 IP 直接访问，容器与宿主机通过端口映射来访问。
- `top` 在容器中可以看到进程级的 CPU 使用情况，但它不了解容器的 cgroups 限制，因此不能准确反映容器整体的 CPU 使用率。要查看准确的容器 CPU 使用情况，应使用 `docker stats` 或基于 `/proc/<pid>/stat` 中的信息写脚本来计算，或者使用 Prometheus+Grafana 这种专业的监控系统
