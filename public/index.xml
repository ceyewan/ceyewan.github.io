<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Ceyewan&#39;s Blog</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Ceyewan&#39;s Blog</description>
    <generator>Hugo -- 0.147.3</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 28 Jun 2025 22:03:32 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>K8s 实战教程</title>
      <link>http://localhost:1313/posts/cloud-native/295cf1c4/</link>
      <pubDate>Sat, 28 Jun 2025 22:03:32 +0800</pubDate>
      <guid>http://localhost:1313/posts/cloud-native/295cf1c4/</guid>
      <description>&lt;p&gt;Kubernetes（简称 K8s）已成为云原生时代的标准，是构建、部署和管理可扩展应用的事实上的操作系统。掌握它对于现代软件工程师和运维专家而言至关重要。&lt;/p&gt;
&lt;p&gt;本教程将采用一种循序渐进的实战方法。我们将从最基础的 &lt;strong&gt;Container（容器）&lt;/strong&gt; 概念出发，通过逐步迭代和完善配置文件，引导你掌握 Pod、Deployment、Service、Ingress 等核心资源。最终，你将学会如何使用 Helm 将所有组件打包，实现一套完整服务的自动化部署。&lt;/p&gt;
&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;在开始之前，请确保你的开发环境满足以下要求。本教程主要参考自这篇优秀的 &lt;a href=&#34;https://guangzhengli.com/courses/kubernetes&#34;&gt;教程&lt;/a&gt;，并结合了个人实践。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;容器运行时与 Kubernetes 集群&lt;/strong&gt;：你需要一个容器运行时（如 Docker）和一个本地 Kubernetes 集群。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;推荐方案 (macOS)&lt;/strong&gt;：使用 &lt;a href=&#34;https://orbstack.dev/&#34;&gt;OrbStack&lt;/a&gt;。它集成了 Docker 和 Kubernetes，一键启动即可获得完整的开发环境，无需额外安装 Minikube 或 Docker Desktop。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Kubernetes 命令行工具&lt;/strong&gt;：安装 &lt;code&gt;kubectl&lt;/code&gt;，它是与 Kubernetes 集群交互的核心工具。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器镜像仓库&lt;/strong&gt;：注册一个容器镜像仓库账号，如 Docker Hub、阿里云 ACR 或其他公有/私有仓库，并使用 &lt;code&gt;docker login&lt;/code&gt; 命令登录。我们后续构建的镜像将推送到这里。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;container&#34;&gt;Container&lt;/h2&gt;
&lt;p&gt;我们的云原生之旅始于最核心的构建块：&lt;strong&gt;容器 (Container)&lt;/strong&gt;。容器将应用程序及其所有依赖项打包在一起，确保其在任何环境中都能以一致的方式运行。主要氛围三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编写一个简单的 Go Web 应用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用多阶段构建 (Multi-stage Build) 的 &lt;code&gt;Dockerfile&lt;/code&gt; 将其打包成一个轻量、安全的镜像&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编写一个脚本来自动化构建和推送镜像的流程&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;选择 Go 语言是因为它在云原生领域广受欢迎，其主要优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;静态编译&lt;/strong&gt;：生成无外部依赖的单个二进制文件，非常适合容器化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨平台&lt;/strong&gt;：轻松编译适用于不同操作系统和架构（如 &lt;code&gt;linux/amd64&lt;/code&gt;）的程序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高性能&lt;/strong&gt;：天生支持并发，内存占用低，非常适合构建高效的微服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了构建一个最优的容器镜像，我们将采用&lt;strong&gt;多阶段构建（Multi-stage Build）&lt;/strong&gt; 策略。这是一种最佳实践，能有效减小镜像体积并提高安全性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构建阶段 (Builder Stage)&lt;/strong&gt;：使用一个包含完整 Go 工具链的基础镜像来编译我们的源代码，生成一个静态链接的可执行文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终阶段 (Final Stage)&lt;/strong&gt;：使用一个极简的基础镜像（如 &lt;code&gt;distroless&lt;/code&gt;），它仅包含运行程序所必需的库。我们只将上一步生成的可执行文件拷贝进来，完全抛弃了 Go 编译环境和源代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这种方式，最终镜像的体积可以从数百 MB 锐减到约 10MB，极大地提升了分发效率和安全性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>虚拟化与容器化概述</title>
      <link>http://localhost:1313/posts/cloud-native/4b9fc30e/</link>
      <pubDate>Sat, 28 Jun 2025 22:01:55 +0800</pubDate>
      <guid>http://localhost:1313/posts/cloud-native/4b9fc30e/</guid>
      <description>&lt;h2 id=&#34;1-虚拟化技术&#34;&gt;1 虚拟化技术&lt;/h2&gt;
&lt;p&gt;KVM（Kernel-based Virtual Machine）是 Linux 内核中的原生虚拟化解决方案，借助硬件辅助虚拟化技术，在一台物理服务器上运行多个独立的虚拟机（VM），每台虚拟机可运行不同的操作系统（如 Windows、Ubuntu 等）。KVM 依赖 &lt;strong&gt;硬件虚拟化支持&lt;/strong&gt;、&lt;strong&gt;Hypervisor 架构&lt;/strong&gt;和 &lt;strong&gt;QEMU 用户态模拟器&lt;/strong&gt;，广泛应用于云计算平台（如 OpenStack、Proxmox）及生产环境中的虚拟化部署。&lt;/p&gt;
&lt;h3 id=&#34;11-硬件辅助虚拟化&#34;&gt;1.1 硬件辅助虚拟化&lt;/h3&gt;
&lt;p&gt;现代 x86 架构 CPU（如 Intel VT-x、AMD-V）内置了虚拟化指令集扩展，允许虚拟机的指令在物理 CPU 上原生执行，从而提升性能并降低虚拟化的实现复杂度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU 虚拟化模式&lt;/strong&gt;：CPU 支持两种运行模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Root Mode&lt;/strong&gt;（VMX Root）：宿主机（Hypervisor）运行的模式；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Non-Root Mode&lt;/strong&gt;（VMX Non-Root）：虚拟机运行的模式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当虚拟机需要执行特权操作（如访问 I/O 设备、CR3 切换等），会触发 &lt;strong&gt;VM-exit&lt;/strong&gt;，退出 Non-Root Mode，由 KVM 接管处理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
硬件虚拟化极大减少了二进制翻译等传统软件模拟技术的开销，使得虚拟机运行更接近原生性能。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;12-hypervisor-架构kvm&#34;&gt;1.2 Hypervisor 架构（KVM）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hypervisor 是一种软件、固件或硬件层，用来在物理硬件和虚拟机（VM）之间提供隔离与资源调度&lt;/strong&gt;。它的主要作用是模拟一个完整的计算机系统（CPU、内存、磁盘、网络等）；管理多个虚拟机对底层物理资源的访问；保证虚拟机之间的安全隔离和资源公平使用。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Type-1&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;裸金属型，直接运行在硬件上，性能高、安全性强&lt;/td&gt;
          &lt;td&gt;KVM、Xen、ESXi&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;Type-2&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;宿主型，运行在操作系统之上，适合桌面环境&lt;/td&gt;
          &lt;td&gt;VirtualBox、VMware Workstation&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;KVM 就是一个 Type-1 类型的 Hypervisor：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然 KVM 运行在 Linux 内核中，但加载 kvm.ko 模块后，&lt;strong&gt;Linux 内核本身就充当了 Hypervisor&lt;/strong&gt; 的角色，因此被归类为 Type-1。&lt;/li&gt;
&lt;li&gt;每个虚拟机以一个普通的 Linux 进程存在，便于调度、监控、资源隔离。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-qemu用户态虚拟设备模拟器&#34;&gt;1.3 QEMU：用户态虚拟设备模拟器&lt;/h3&gt;
&lt;p&gt;KVM 本身只提供 CPU 和内存的虚拟化能力，而不包含虚拟设备（磁盘、网卡、显卡等）模拟能力。QEMU（Quick Emulator）是与 KVM 配套使用的用户空间模拟器，补全虚拟设备层。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 高性能日志库 Zap</title>
      <link>http://localhost:1313/posts/golang-learning/22e8abab/</link>
      <pubDate>Sat, 28 Jun 2025 21:53:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/golang-learning/22e8abab/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/uber-go/zap&#34;&gt;Zap&lt;/a&gt; 是 Uber 开源的一款&lt;strong&gt;结构化&lt;/strong&gt;、&lt;strong&gt;分级&lt;/strong&gt;、&lt;strong&gt;极致性能优化&lt;/strong&gt;的 Go 日志库。它专为性能敏感的场景设计，支持&lt;strong&gt;强类型字段&lt;/strong&gt;、&lt;strong&gt;高效序列化&lt;/strong&gt;，并兼顾开发体验。&lt;/p&gt;
&lt;p&gt;Zap 提供了两种日志 API：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Logger&lt;/strong&gt;：强类型结构化 API，性能最优；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SugaredLogger&lt;/strong&gt;：支持 &lt;code&gt;fmt.Sprintf&lt;/code&gt; 风格，使用更便捷，性能略低；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-为什么-zap-如此高性能&#34;&gt;1 为什么 Zap 如此高性能？&lt;/h2&gt;
&lt;h3 id=&#34;11-避免反射开销&#34;&gt;1.1 避免反射开销&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统库如 Logrus&lt;/strong&gt;：大量使用 &lt;code&gt;interface{}&lt;/code&gt; 与反射；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Zap&lt;/strong&gt;：使用强类型字段（如 zap.String、zap.Int），绕过反射，性能更优。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;12-减少内存分配&#34;&gt;1.2 减少内存分配&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用 sync.Pool 重用对象，缓解 GC 压力；&lt;/li&gt;
&lt;li&gt;临时缓冲区、日志字段结构都支持复用；&lt;/li&gt;
&lt;li&gt;零分配字符串编码，避免频繁拼接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;13-精简调用链&#34;&gt;1.3 精简调用链&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;其他库：多层接口封装（Logger → Encoder → Formatter）；&lt;/li&gt;
&lt;li&gt;Zap：扁平化设计，Logger → Encoder，直达底层。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;14-非阻塞写入--异步优化&#34;&gt;1.4 非阻塞写入 &amp;amp; 异步优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;日志调用方不直接执行 I/O；&lt;/li&gt;
&lt;li&gt;通过 channel 实现生产者 - 消费者模型，避免阻塞；&lt;/li&gt;
&lt;li&gt;默认同步写入，结合 WriteSyncer 可实现批量输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;15-编码器优化&#34;&gt;1.5 编码器优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;高性能 JSON / Console 编码器；&lt;/li&gt;
&lt;li&gt;直接写入 &lt;code&gt;[]byte&lt;/code&gt;，绕过字符串中间态；&lt;/li&gt;
&lt;li&gt;支持颜色、高亮、字段定制等扩展性良好的格式化能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;16-高性能-api-设计&#34;&gt;1.6 高性能 API 设计&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;明确区分性能优先（Logger）与开发便捷（SugaredLogger）两条路径；&lt;/li&gt;
&lt;li&gt;鼓励在核心路径中使用 Logger，在外围使用 SugaredLogger。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-结构化日志&#34;&gt;2 结构化日志&lt;/h2&gt;
&lt;p&gt;传统日志多为文本拼接，机器难以解析。而结构化日志以 &lt;strong&gt;键值对&lt;/strong&gt; 方式记录，天然适配 JSON、可直接被日志平台（如 ELK、Loki）解析。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 库函数和内置方法</title>
      <link>http://localhost:1313/posts/golang-learning/21b8541d/</link>
      <pubDate>Sat, 28 Jun 2025 21:53:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/golang-learning/21b8541d/</guid>
      <description>&lt;h2 id=&#34;1-list&#34;&gt;1 List&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;container/list&lt;/code&gt; 包提供了一个双向链表的实现。双向链表是一种常见的数据结构，支持高效的插入、删除和遍历操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;l:= list.New()&lt;/code&gt;：创建一个新的双向链表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.PushFront(value)&lt;/code&gt;：在链表头部插入一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.PushBack(value)&lt;/code&gt;：在链表尾部插入一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.InsertBefore(value, mark)&lt;/code&gt;：在 &lt;code&gt;mark&lt;/code&gt; 元素之前插入一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.InsertAfter(value, mark)&lt;/code&gt;：在 &lt;code&gt;mark&lt;/code&gt; 元素之后插入一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.Remove(elem)&lt;/code&gt;：删除链表中的指定元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.MoveToFront(elem)&lt;/code&gt;：将元素移动到链表头部。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.MoveToBack(elem)&lt;/code&gt;：将元素移动到链表尾部。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.MoveBefore(elem, mark)&lt;/code&gt;：将元素移动到 &lt;code&gt;mark&lt;/code&gt; 元素之前。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.MoveAfter(elem, mark)&lt;/code&gt;：将元素移动到 &lt;code&gt;mark&lt;/code&gt; 元素之后。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.Front()&lt;/code&gt;：获取链表头部的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.Back()&lt;/code&gt;：获取链表尾部的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.Len()&lt;/code&gt;：返回链表中元素的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;container/heap&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;l&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#6639ba&#34;&gt;Front&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;();&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;nil&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;e&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#6639ba&#34;&gt;Next&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#1f2328&#34;&gt;fmt&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#6639ba&#34;&gt;Println&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;Value&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的 &lt;code&gt;e&lt;/code&gt; 的类型是 &lt;code&gt;*list.Element&lt;/code&gt;，即指向 &lt;code&gt;list.Element&lt;/code&gt; 结构体的指针。其中包括 &lt;code&gt;next&lt;/code&gt; 和 &lt;code&gt;prev&lt;/code&gt; 两个指针，&lt;code&gt;list&lt;/code&gt; 指向该元素所属的链表，最后是 &lt;code&gt;Value&lt;/code&gt;，表示该元素存储的值，类型是 &lt;code&gt;interface{}&lt;/code&gt; 可以存储任何类型的值。&lt;/p&gt;
&lt;p&gt;因此，假设我们向链表中写入的是一个结构体，那么需要进行一次&lt;strong&gt;类型断言&lt;/strong&gt;，然后再来获取结构体里面的值，如 &lt;code&gt;e.Value.(*CacheItem).key&lt;/code&gt; 和 &lt;code&gt;e.Value.(*CacheItem).value&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;2-heap&#34;&gt;2 Heap&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;container/heap&lt;/code&gt; 包提供了一个堆的实现。堆是一种特殊的树形数据结构，通常用于实现优先队列。堆分为最小堆和最大堆，&lt;code&gt;container/heap&lt;/code&gt; 包默认实现的是最小堆。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;h:= &amp;amp;Heap{}&lt;/code&gt;：创建一个堆对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap.Init(h)&lt;/code&gt;：初始化堆，使其满足堆的性质。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap.Push(h, value)&lt;/code&gt;：向堆中插入一个元素，并保持堆的性质。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap.Pop(h)&lt;/code&gt;：从堆中删除并返回最小（或最大）的元素，并保持堆的性质。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h[0]&lt;/code&gt;：获取堆顶元素（最小或最大元素），但不删除它。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len(h)&lt;/code&gt;：返回堆中元素的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;hp&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;[]&lt;/span&gt;&lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;ListNode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;hp&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;Len&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;hp&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;Less&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;].&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;Val&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;j&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;].&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;Val&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#57606a&#34;&gt;// 最小堆&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;hp&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;Swap&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;],&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;j&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;j&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;],&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;hp&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;Push&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;any&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;append&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;v&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.(&lt;/span&gt;&lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;ListNode&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;hp&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;Pop&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;any&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#6639ba&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#0550ae&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0550ae&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;];&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[:&lt;/span&gt;&lt;span style=&#34;color:#6639ba&#34;&gt;len&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#0550ae&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#0550ae&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;];&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要使用 &lt;code&gt;container/heap&lt;/code&gt; 包，需要实现 &lt;code&gt;heap.Interface&lt;/code&gt; 接口，该接口包含 &lt;code&gt;sort.Interface&lt;/code&gt; 接口和 &lt;code&gt;Push&lt;/code&gt;、&lt;code&gt;Pop&lt;/code&gt; 方法，而 &lt;code&gt;sort.Interface&lt;/code&gt; 接口又要求实现 &lt;code&gt;Len&lt;/code&gt;、&lt;code&gt;Less&lt;/code&gt;、&lt;code&gt;Swap&lt;/code&gt; 这三种方法。因此，最后就是要实现上面这五种方法，不过还好，都挺容易的。注意，&lt;code&gt;Push&lt;/code&gt; 和 &lt;code&gt;Pop&lt;/code&gt; 都是操作的最后一个元素。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 热重载工具 Air</title>
      <link>http://localhost:1313/posts/golang-learning/a793fe12/</link>
      <pubDate>Sat, 28 Jun 2025 21:53:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/golang-learning/a793fe12/</guid>
      <description>&lt;p&gt;air 是一款专为 Go 项目设计的&lt;strong&gt;热重载工具&lt;/strong&gt;，它能够在开发者保存代码文件时自动触发重新编译并重启程序。相比直接使用 &lt;code&gt;go run&lt;/code&gt; 命令，air 提供了更多实用功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持自定义构建和运行命令&lt;/li&gt;
&lt;li&gt;避免路径错误和日志丢失问题&lt;/li&gt;
&lt;li&gt;配置灵活且使用简单&lt;/li&gt;
&lt;li&gt;显著提升本地开发效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-安装&#34;&gt;1 安装&lt;/h2&gt;
&lt;p&gt;安装 air 非常简单，只需执行以下命令：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;go install github.com/air-verse/air@latest
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 主要作用是&lt;strong&gt;将某个模块加入 go.mod&lt;/strong&gt;，并下载源码到本地缓存（GOPATH/pkg/mod）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 主要用于&lt;strong&gt;安装 CLI 工具或构建你自己的可执行程序&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-使用&#34;&gt;2 使用&lt;/h2&gt;
&lt;h3 id=&#34;21-基础使用&#34;&gt;2.1 基础使用&lt;/h3&gt;
&lt;p&gt;最简单的使用方式是直接在项目目录下运行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;air
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这会使用默认配置启动热重载功能。但更推荐的方式是通过配置文件进行详细配置。&lt;/p&gt;
&lt;h3 id=&#34;22-配置文件&#34;&gt;2.2 配置文件&lt;/h3&gt;
&lt;p&gt;执行以下命令生成默认配置文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;air init
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这会生成一个 &lt;code&gt;.air.toml&lt;/code&gt; 文件，内容类似：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#57606a&#34;&gt;# .air.toml&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;go build -o ./tmp/main ./main.go&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#57606a&#34;&gt;# 指定构建命令，产出你要执行的 ./main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;bin&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;./tmp/main&amp;#34;&lt;/span&gt;                        &lt;span style=&#34;color:#57606a&#34;&gt;# air 会运行这个二进制文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;full_bin&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;true&lt;/span&gt;                           &lt;span style=&#34;color:#57606a&#34;&gt;# 使用完整路径（不加的话在某些环境变量下会找不到）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;run&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;cmd&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;                                  &lt;span style=&#34;color:#57606a&#34;&gt;# 不加的话 air 会自动运行上面 build 出来的 bin&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;time&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;23-配置详解&#34;&gt;2.3 配置详解&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;构建配置&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmd&lt;/code&gt;：指定构建命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bin&lt;/code&gt;：指定构建输出的可执行文件路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;full_bin&lt;/code&gt;：是否使用完整路径（避免环境变量问题）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行配置&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmd&lt;/code&gt;：可指定运行命令（留空则自动运行构建出的二进制文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志配置&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;time&lt;/code&gt;：是否显示时间戳&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-高级用法&#34;&gt;3 高级用法&lt;/h2&gt;
&lt;h3 id=&#34;31-自定义构建命令&#34;&gt;3.1 自定义构建命令&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;air --build.cmd &lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;go build -o bin/api cmd/run.go&amp;#34;&lt;/span&gt; --build.bin &lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;./bin/api&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;32-排除特定目录&#34;&gt;3.2 排除特定目录&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;air --build.exclude_dir &lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;templates,build&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;33-传递运行参数&#34;&gt;3.3 传递运行参数&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#57606a&#34;&gt;# Will run ./tmp/main server --port 8080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;air server --port &lt;span style=&#34;color:#0550ae&#34;&gt;8080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4-注意事项&#34;&gt;4 注意事项&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;不要使用 &lt;code&gt;go run&lt;/code&gt;&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;air 的底层机制是编译后执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go run&lt;/code&gt; 会在临时目录构建，可能导致路径问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;临时文件位置&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;air 默认将编译好的程序放在 &lt;code&gt;tmp&lt;/code&gt; 文件夹&lt;/li&gt;
&lt;li&gt;确保你的项目有适当的 &lt;code&gt;.gitignore&lt;/code&gt; 配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与热部署的区别&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;热重载&lt;/strong&gt;：开发环境使用，修改代码后自动编译 + 运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;热部署&lt;/strong&gt;：生产环境使用，实现不中断服务的版本更新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE] 热重载&amp;amp;热部署
&lt;strong&gt;热重载&lt;/strong&gt;：改代码后自动编译 + 运行，常用于开发环境（如 air）；
&lt;strong&gt;热部署&lt;/strong&gt;：上线新版本时不中断服务，常用于生产环境，涉及滚动发布、负载均衡等；
&lt;strong&gt;守护进程&lt;/strong&gt;：程序崩溃或退出后自动重启，保持服务持续运行，如 systemd 和 docker；&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 性能分析工具 Pprof</title>
      <link>http://localhost:1313/posts/golang-learning/6b074835/</link>
      <pubDate>Sat, 28 Jun 2025 21:53:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/golang-learning/6b074835/</guid>
      <description>&lt;p&gt;pprof 是 Go 官方内置的性能分析工具，用于采集并分析 Go 程序的运行时性能数据，帮助开发者发现 CPU 瓶颈、内存泄漏、阻塞等待等问题。具体来说，支持 CPU、Memory、Block、Goroutine、Heap Profiling 等。&lt;/p&gt;
&lt;p&gt;首先，应用程序通过 &lt;code&gt;import _ &amp;quot;net/http/pprof&amp;quot;&lt;/code&gt; 匿名导入 pprof 包，用于在程序中进行插桩，然后通过下面的代码在对应端口启动 pprof 服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;func&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#1f2328&#34;&gt;http&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#6639ba&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;localhost:6060&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;nil&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;}()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，就可以通过浏览器访问 &lt;code&gt;http://127.0.0.1:6060/debug/pprof/&lt;/code&gt;，可以看到如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image.png&#34; loading=&#34;lazy&#34; src=&#34;https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250512152450.png&#34;&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;类型&lt;/th&gt;
          &lt;th style=&#34;text-align: center&#34;&gt;描述&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;allocs&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;内存分配情况的采样信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;blocks&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;阻塞操作情况的采样信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;cmdline&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;显示程序启动命令及参数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;goroutine&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;当前所有协程的堆栈信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;heap&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;堆上内存使用情况的采样信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;mutex&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;锁争用情况的采样信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;profile&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;CPU 占用情况的采样信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;threadcreate&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;系统线程创建情况的采样信息&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;trace&lt;/td&gt;
          &lt;td style=&#34;text-align: center&#34;&gt;程序运行跟踪信息&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于直接看网页不够直观，可以借助 &lt;code&gt;go tool pprof&lt;/code&gt; 工具来排查。&lt;/p&gt;
&lt;h2 id=&#34;1-cpu-调优&#34;&gt;1 CPU 调优&lt;/h2&gt;
&lt;p&gt;通过 &lt;code&gt;go tool pprof &amp;quot;http://localhost:6060/debug/pprof/profile?seconds=30&amp;quot;&lt;/code&gt; 获取近 30 秒的执行记录，然后会进入到一个命令行交互界面，我们可以通过 &lt;code&gt;top&lt;/code&gt; 命令查看 CPU 资源使用量的排序，通过 &lt;code&gt;list xxx&lt;/code&gt; 查看相关代码段的实现，通过 &lt;code&gt;web&lt;/code&gt; 命令生成一个可视化的界面。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 远程过程调用标准库与 GRPC</title>
      <link>http://localhost:1313/posts/golang-learning/ccbc66d4/</link>
      <pubDate>Sat, 28 Jun 2025 21:53:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/golang-learning/ccbc66d4/</guid>
      <description>&lt;h2 id=&#34;1-rpc-核心概念与通信基础&#34;&gt;1 RPC 核心概念与通信基础&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;RPC（Remote Procedure Call）远程过程调用&lt;/strong&gt; 是一种使程序可以调用另一台机器上函数的通信协议，开发者可以像调用本地函数一样透明地调用远程服务。这种抽象极大简化了分布式系统中服务之间的交互逻辑，是微服务架构中最基础的通信手段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]
&lt;strong&gt;RPC（Remote Procedure Call）&lt;/strong&gt;：远程过程调用是一种封装通信细节的机制，允许开发者调用远程服务如同本地函数。常见实现包括 gRPC、Thrift、Dubbo 等。它屏蔽了底层网络传输、数据序列化等复杂性，是构建现代微服务系统的基础。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IPC（Inter-Process Communication）&lt;/strong&gt;：进程间通信用于同一主机内多个进程的数据交换与协同，方式包括管道、消息队列、共享内存、信号、Socket 等。IPC 更多用于单机多进程协作，RPC 更适合跨网络服务交互。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在软件系统从单体架构向微服务架构演化的过程中，不同服务部署在不同主机或容器中，模块之间无法通过函数调用直接通信。此时，就需要一种通信机制，&lt;strong&gt;既能跨进程、跨主机调用远程服务，又不需要开发者处理底层细节&lt;/strong&gt;——这就是 RPC 诞生的背景。&lt;/p&gt;
&lt;h3 id=&#34;11-rpc-核心组成与工作流程&#34;&gt;1.1 RPC 核心组成与工作流程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;客户端存根（Client Stub）&lt;/strong&gt;：负责将客户端的函数调用请求序列化成网络消息，并发送给服务端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务端骨架（Server Stub）&lt;/strong&gt;：负责接收客户端的请求，反序列化消息，调用相应的服务函数，并将结果序列化后返回给客户端。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列化协议&lt;/strong&gt;：定义了数据如何序列化和反序列化，常见的序列化协议有 JSON、Protobuf 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输协议&lt;/strong&gt;：定义了网络消息如何传输，常见的传输协议有 TCP、HTTP、gRPC（基于 HTTP/2）等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-最简-rpc-示例helloworld&#34;&gt;2 最简 RPC 示例：HelloWorld&lt;/h2&gt;
&lt;h3 id=&#34;21-标准库实现&#34;&gt;2.1 标准库实现&lt;/h3&gt;
&lt;p&gt;Go 语言标准库中提供了一个内置的 RPC 包 &lt;code&gt;net/rpc&lt;/code&gt;，用于实现远程过程调用。它基于自定义的二进制协议，支持通过原始 TCP 或 HTTP 通信。不过，&lt;code&gt;net/rpc&lt;/code&gt; 不支持 HTTP/2，因此无法享受到如多路复用、流量控制等高级特性，性能上也相对有限，适合学习和内部系统使用。&lt;/p&gt;
&lt;p&gt;首先，我们定义一个 HelloService 类型，并在其中实现一个符合 RPC 规范的方法 SayHello：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;HelloService&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;HelloService&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;SayHello&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;request&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;reply&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;string&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0550ae&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;reply&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;Hello World:&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;request&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#cf222e&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#cf222e&#34;&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Go 的 RPC 方法必须满足以下规范：方法必须是&lt;strong&gt;导出方法&lt;/strong&gt;（首字母大写）。方法只能有&lt;strong&gt;两个可序列化&lt;/strong&gt;的参数；第一个参数是请求参数，类型必须是导出或内建类型；第二个参数是响应参数的&lt;strong&gt;指针类型&lt;/strong&gt;；并且必须返回一个 error 类型。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go 中的优雅关闭 Graceful Shutdown</title>
      <link>http://localhost:1313/posts/golang-learning/abf1fab9/</link>
      <pubDate>Sat, 28 Jun 2025 21:53:07 +0800</pubDate>
      <guid>http://localhost:1313/posts/golang-learning/abf1fab9/</guid>
      <description>&lt;p&gt;对于现代的 HTTP 服务器和容器化应用，优雅关闭不仅仅是一个好习惯，更是确保服务不中断的关键措施。一个优雅的关闭过程通常需要满足以下三个核心条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;停止接受新请求或消息&lt;/strong&gt;：在关闭应用时，首先要确保系统不再接收新的 HTTP 请求或消息。此时，仍然保持与数据库、缓存等外部系统的连接，避免中断外部服务的通信。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;等待正在处理的请求完成&lt;/strong&gt;：关闭过程中，应该等待所有正在处理的请求完成，防止已有的请求因为服务突然关闭而未被正确响应。对于请求超时的情况，提供优雅的错误响应或通知用户，确保用户获得清晰的服务状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放关键资源并执行清理&lt;/strong&gt;：在关闭过程中，及时释放关键资源至关重要。这包括数据库连接、文件锁、网络监听器等。所有资源都应当在退出前清理，确保不会留下任何潜在的资源泄漏或死锁问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE] 优雅退出
&lt;strong&gt;优雅退出&lt;/strong&gt;指程序或系统在终止时主动释放资源、保存状态并妥善处理未完成任务，确保数据完整性和服务连续性，避免强制中断导致的错误或损坏。常见于后台服务、多线程应用或分布式系统，通过捕获退出信号、清理临时文件、关闭数据库连接等步骤实现平稳关闭，提升可靠性与用户体验。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;1-捕获信号&#34;&gt;1 捕获信号&lt;/h2&gt;
&lt;p&gt;优雅关闭的第一步是捕获终止信号，这些信号通知应用程序该退出并开始关闭过程。信号是一种&lt;strong&gt;软件中断&lt;/strong&gt;，通知进程发生了特定事件。操作系统会中断进程的正常流程并传递信号。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Signal handler&lt;/strong&gt;：应用程序可以为特定信号注册处理函数，接收到信号时自动执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Default action&lt;/strong&gt;：如果未注册处理函数，进程会按信号的默认行为处理，如终止或忽略。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unblockable signals&lt;/strong&gt;：某些信号（如 SIGKILL）无法被捕获或忽略，它们直接终止进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Go 应用启动时，&lt;strong&gt;Go 运行时&lt;/strong&gt;自动处理常见的终止信号，如 SIGINT、SIGTERM 和 SIGHUP。其中，最常用于优雅关闭的信号是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SIGTERM&lt;/strong&gt;：请求优雅退出，Kubernetes 通常是发送该信号终止该程序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SIGINT&lt;/strong&gt;：中断，用户通过 Ctrl+C 中断进程时触发；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SIGHUP&lt;/strong&gt;：挂断，用于通知应用程序重新加载配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE] Go 如何终止程序
当 Go 应用程序收到 SIGTERM 时，Go 运行时会通过内置的信号处理器捕获它，首先检查是否注册了自定义处理器。如果没有，运行时会暂时禁用自定义处理器，并再次向应用程序发送相同的信号 (SIGTERM)。此时，操作系统会使用默认行为终止进程。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在 Go 中，你可以通过 os/signal 包注册自定义信号处理器来覆盖默认的信号处理行为。以下是一个处理 SIGINT 和 SIGTERM 信号的示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;main&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#1f2328&#34;&gt;signalChan&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#6639ba&#34;&gt;make&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#cf222e&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;os&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;Signal&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#0550ae&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#1f2328&#34;&gt;signal&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#6639ba&#34;&gt;Notify&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;signalChan&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;syscall&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;SIGINT&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#1f2328&#34;&gt;syscall&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;SIGTERM&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#57606a&#34;&gt;// 其他初始化工作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#0550ae&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;signalChan&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#1f2328&#34;&gt;fmt&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#6639ba&#34;&gt;Println&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#0a3069&#34;&gt;&amp;#34;收到终止信号，正在关闭…&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#1f2328&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;signal.Notify 告诉 Go 运行时将指定的信号发送到自定义的信号通道，而不是使用默认的终止行为。这样，你可以手动处理信号并避免程序自动终止。&lt;/p&gt;</description>
    </item>
    <item>
      <title>About</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sat, 28 Jun 2025 12:05:45 +0800</pubDate>
      <guid>http://localhost:1313/about/</guid>
      <description></description>
    </item>
    <item>
      <title>Model Context Protocol Crash Course</title>
      <link>http://localhost:1313/posts/model-context-protocol-crash-course/</link>
      <pubDate>Wed, 25 Jun 2025 22:12:45 +0800</pubDate>
      <guid>http://localhost:1313/posts/model-context-protocol-crash-course/</guid>
      <description>&lt;h2 id=&#34;1-引言&#34;&gt;1 引言&lt;/h2&gt;
&lt;p&gt;在 AI 领域，尤其是大语言模型（LLM）应用中，&lt;strong&gt;如何让模型灵活获取外部实时信息、调用工具、集成多源数据&lt;/strong&gt;，一直是开发者面临的核心难题。&lt;br&gt;
MCP（Model Context Protocol，模型上下文协议）正是为了解决这一痛点而诞生的，它就像 AI 世界的 &amp;ldquo;USB-C&amp;rdquo;，统一了 AI 与外部能力（工具、资源等）之间的连接标准。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;image.png&#34; loading=&#34;lazy&#34; src=&#34;https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250621105636.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;11-llm-的局限与需求&#34;&gt;1.1 LLM 的局限与需求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LLM 的知识固化在训练数据中，无法主动获取实时信息。&lt;/li&gt;
&lt;li&gt;传统 prompt 工程、RAG 检索、手动集成工具等方式各有不足，难以满足复杂、动态需求。&lt;/li&gt;
&lt;li&gt;需要一个&lt;strong&gt;标准化、可扩展、易集成的协议&lt;/strong&gt;，让模型能像调用 USB 设备一样调用外部能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-llms-的上下文管理&#34;&gt;2 LLMs 的上下文管理&lt;/h2&gt;
&lt;h3 id=&#34;21-传统方法&#34;&gt;2.1 传统方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;截断/滑动窗口&lt;/strong&gt;：保留最近对话，丢弃旧信息，易丢失重要上下文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;摘要法&lt;/strong&gt;：对长内容做摘要，易丢失细节且需要额外计算。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模板化 prompt&lt;/strong&gt;：预留插槽（slots）手动填充信息，开发负担大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-rag检索增强生成&#34;&gt;2.2 RAG（检索增强生成）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;外部系统负责检索，模型被动接收，无法主动发起信息获取。&lt;/li&gt;
&lt;li&gt;主要解决知识查找，但不支持 &amp;quot; 调用工具 &amp;quot; 类操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;23-prompt-链与-agent&#34;&gt;2.3 Prompt 链与 Agent&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;利用模型输出特殊指令（如 &lt;code&gt;SEARCH: xxx&lt;/code&gt;）由外部系统解析执行。&lt;/li&gt;
&lt;li&gt;实现了初步的 &amp;quot; 推理 + 行动 &amp;ldquo;（ReAct），但缺乏标准，集成脆弱，难以复用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;24-函数调用-function-calling&#34;&gt;2.4 函数调用 Function Calling&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;结构化定义可调用函数，模型输出 JSON 指令，由外部执行并反馈结果。&lt;/li&gt;
&lt;li&gt;结构化程度提升，但仍需为每对模型与工具定制 glue code，维护困难。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;25-mn-集成难题&#34;&gt;2.5 M×N 集成难题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;N 个工具 × M 个 AI 应用，需开发 N×M 套集成代码，极其低效。&lt;/li&gt;
&lt;li&gt;工具与模型间缺乏统一标准，导致 &amp;quot; 集成地狱 &amp;ldquo;，迫切需要一套标准协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-mcp模型上下文协议&#34;&gt;3 MCP：模型上下文协议&lt;/h2&gt;
&lt;h3 id=&#34;31-mcp-是什么&#34;&gt;3.1 MCP 是什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：MCP 是一种开放的、标准化的协议，规范了 AI 应用与外部工具/资源的交互方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：像 USB-C 一样，MCP 让任何 AI 应用与任何 MCP 能力（工具/资源/提示词）都能即插即用、互操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;开发者只需实现一次 MCP 客户端/服务器，即可集成所有能力，极大降低开发和维护成本。&lt;/li&gt;
&lt;li&gt;工具/资源提供方只需实现一次 MCP 服务端，即可服务所有支持 MCP 的 AI 应用。&lt;/li&gt;
&lt;li&gt;用户获得更强大、更灵活、更实时的 AI 助手体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;image.png&#34; loading=&#34;lazy&#34; src=&#34;https://ceyewan.oss-cn-beijing.aliyuncs.com/typora/20250621111133.png&#34;&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
